#+TITLE: Project file for tree-lang
#+AUTHOR: Bart Frenk
#+EMAIL: bart.frenk@gmail.com

* Contents
** Roadmap
*** DONE Add comparison operators to the language
CLOSED: [2018-04-26 Thu 13:42]
*** DONE Write an interpreter
CLOSED: [2018-04-26 Thu 13:43]
*** TODO Add string interpolation
Maybe use {} interpolation syntax, e.g., "Welcome to {$location.city}!"
*** TODO Make the interpreter safer by using GADTs to restrict its output
*** DONE Write a typechecker
CLOSED: [2018-04-24 Tue 23:12]
We need to have an entry in the type context for all the fields of the context
macros in the program. Such entries are just trees with the types at the
leaves.
*** TODO Write a totality checker
By this I mean a checker that checks whether every branch of the program has the
correct assignments.
*** TODO Deduplicate the assignments that come out of the interpreter
*** TODO Include position in the error message
*** Add data constructors
**** TODO Add data constructor for tuples
**** TODO Add data constructor for lists
** Issues
*** TODO Separation of statements by linebreaks does not work
I think this is due to reliance on the Text.Parsec.Token lexer, which considers
a linebreak white space to be ignored. Needs to be confirmed. See for example
the programs =minimalParseFailure=, =counterExample1= and =counterExample2= in
=TreeLang.Examples=.

If my hypothesis is correct, there seem to be two angles of attack for this
issue:
1. make use of indent parser, to make the language fully indentation sensitive
2. write a lexer from scratch (by copy-pasting from Text.Parsec.Token)
** Ideas
*** DONE Haxl interpreter (POC)
CLOSED: [2018-04-27 Fri 00:55]
Write an interpreter from programs into the Haxl monad. It would then probably
be wise to define data sources for every top-level context macro name. The tail
of the context macro names is then used to access the resulting object.

This would allow for easy concurrent data access.
*** What about failures to dereference context macros?
The language should have a good concept of unknowns. Dereferencing the context
macros might fail.
*** Can we take into account optimal adaptive placeholder selection into the language?
This is very preliminary. I am thinking of something like =title = [{"Welcome!",
"Hey!"}|gender]=, to automatically select the title from the two
options given based on the gender.



*** Make context macros functions
*Branch:* =feature/add-functions=

This would entail

#+begin_src haskell
data Expr
  = ContextMacro [Expr] String
  ...
#+end_src

in which the list of expressions are the arguments to the function (it might
also be a map of expressions, if named arguments are required: I think it is
better for it to be a map, since that would make it easier to implement generic
datasources. Just serialize the map to JSON and post it to the supplied resource).

Then the =lookupObj= function would need to return a function from =[Expr]= to
=(ContextObj Expr)=.

It would now also be better to have GADTs restrict the type of the expression to
passed in. We could then partition the Expr's into Values and Reducibles, and
have the Haskell type checker ensure that only values are passed to the
context macro.

It would now be best to have the type checker to know about functions (with
named arguments, if arguments to context macros are passed as maps).
